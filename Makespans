    taskDurations = [];
    for j = 1:length(jobs)
        job = jobs(j);
        for k = 1:length(job.topology)
            op = job.topology(k);
            taskDurations = [taskDurations; min(op.time)]; 
        end
    end
    %Q = eye(length(taskDurations)); 
    f = zeros(1, numTrans);
    for i = 1:numTrans
        f(i) = taskDurations(i);  
    end
    precedenceConstraints = [];
    for j = 1:length(jobs)
        job = jobs(j);
        for k = 1:length(job.topology)
            op = job.topology(k);
            op_id = sprintf('J%dO%d', job.id, op.id);
            startPlaceIdx = placeMap([op_id, '_start']);
            finishPlaceIdx = placeMap([op_id, '_finish']);
            for sucIdx = 1:length(op.sucessors)
                sucId = op.sucessors(sucIdx);
                sucOp = job.topology(sucId);  % Get the successor operation
                sucOp_id = sprintf('J%dO%d', job.id, sucOp.id);
                finishPlaceIdx_suc = placeMap([sucOp_id, '_finish']);
                precedenceConstraints = [precedenceConstraints; C(i) >= C(sucId) + B(startPlaceIdx, finishPlaceIdx_suc)];
            end
        end
    end
    u = zeros(numTrans, 1); 
    options = optimoptions('intlinprog', 'Display', 'off');
    [solution, fval] = intlinprog(f, 1:numTrans, [], [], [], [], zeros(1, numTrans), ones(1, numTrans), options);
    Cmax = fval;
